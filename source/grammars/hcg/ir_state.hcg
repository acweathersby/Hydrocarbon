# Copyright (C) 2021 Anthony Weathersby - The Hydrocarbon Parser Compiler
# see /source/typescript/hydrocarbon.ts for full copyright and warranty 
# disclaimer notice.

# version 6.0


@IMPORT ./comments.hcg as cm

@IMPORT ./symbols.hcg as sym

@IMPORT ./functions.hcg as fn

@IGNORE g:sp g:nl tk:cm::comment

<> state_ir > 
        
        state_declaration top_level_instructions on_fail? expected_symbols?   
                                            
                                            f:r { { type:"state", id:$1, instructions: $2, fail: $3, symbol_meta:$4 } }

<> grammar_injection > 
        
        \<[ ( tk:state_hash_token | t:recover sym::production_symbol ) \] 
        
                top_level_instructions on_fail? expected_symbols? \>
                                            
                                            f:r { { type:"state", id:$2, instructions: $4, fail: $5, symbol_meta:$6 } }

<> state_declaration > 
        
        t:state \[  tk:state_hash_token \]     
                                            f:r { $3 + "" }

<> state_reference > 
        
        t:state \[ ( 
                        tk:state_hash_token             
                        
                        f:r { $1 + "" }
                |       sym::production_symbol
                ) \]     
                                            
                                            f:r { $3 }

<> top_level_instructions > 

        assertion_instruction(+) 
    
    |   instruction_sequence                             

<> instruction_sequence > 

        sequence_instruction(+ t:then ) 
        ( t:then goto_instruction(+ t:then ) )? 
        ( t:then t:repeat t:state f:r{ { type:"repeat-state" } } )? 
        
                                            f:r{ [...$1, ...$2, $3] }

    |   goto_instruction(* t:then ) ( t:then t:repeat t:state f:r{ { type:"repeat-state" } } )? 
        
                                            f:r{ [...$1, $2] }

<> assertion_instruction >

        t:assert  \PRODUCTION  production_id_list \( instruction_sequence \)                     
                                            
                                            f:r { { type: $1 + "", mode:$2 + "", ids: $3, instructions: $5} }

        |
    
        ( t:assert | t:peek ) ( \TOKEN | \BYTE | \CODEPOINT | \CLASS ) token_id_list \( instruction_sequence \)                     
                                            
                                            f:r { { type: $1 + "", mode:$2 + "", ids: $3, instructions: $5} }

<> goto_instruction > 

    t:goto state_reference
                                            f:r { { type:"goto", state: $2 } }
<> sequence_instruction >

        t:reduce g:num g:num           
                                            f:r { { type:"reduce", len: +$2, reduce_fn: +$3 } }

    |   t:reduce fn::reduce_function   
                                            
                                            f:r { { type:"reduce", len: -1, reduce_fn: $2 } }
    |   t:assign t:token token_id_list  
                                            
                                            f:r { { type:"token-assign", ids: $3 } }

    |   t:set t:prod t:to ( 
                  g:num f:r{ parseInt($1) } 
                |   sym::production_symbol
            )
                                            
                                            f:r { { type:"set-prod", id: $4  } }

    |   t:fork t:to \( state_reference(+\, ) \)
                                            
                                            f:r { { type:"fork-to", states: $4  } }

    |   t:scan t:back? t:until token_id_list
                                            f:r { { type: $2 ? "scan-back-until" : "scan-until", ids: $4 } }

    |   t:set t:token t:id ( ! g:num f:r { parseInt($1) } | sym::terminal_symbol ) g:num
                                           
                                            f:r { { type:"token-id", id: $4  } }

    |   t:pass
                                            f:r { { type:"pass"  } }

    |   t:fail
                                            f:r { { type:"fail" } }

    |   t:not t:within t:scopes \[   ( 
                        g:num f:r{ parseInt($1) } 
                |       sym::production_symbol
            )(+)     
        \]
                                            f:r { { type:"not-in-scopes", ids:$5 } }
                                  
    |   t:set t:scope t:to ( 
                    g:num f:r{ parseInt($1) } 
            )
                                            f:r { { type:"set-scope", scope:$4 } }
                                            
    |   t:consume t:nothing?
                                            f:r { { type:"consume", EMPTY:!!$2 } }
                                    
      

<> on_fail > 
    
    t:on t:fail state_declaration top_level_instructions on_fail? expected_symbols?
                                            
                                            f:r { { type:"on-fail-state", id:$3, instructions: $4, symbol_meta: $6, fail: $5 } }

<> expected_symbols > 

        \symbols: \expected token_id_list
        ( \skipped token_id_list f:r{ $2 } )?

                                            f:r { { type:"symbols", expected:$3, skipped:$4 || [] } }

<> token_id_list > 

        \[ 
            ( 
                        ! g:num f:r{ +$1 } 
                |       sym::terminal_symbol
            )(+) 
        \] 
                                            f:r { $2 }

<> production_id_list > 

        \[ 
            ( 
                        g:num f:r{ parseInt($1) } 
                |       sym::production_symbol
            )(+) 
        \] 
                                            f:r { $2 }

<> state_hash_token > 

        state_hash_token (RST g:sp g:nl)  ( \_ | \- | g:id | g:num )

    |   g:id

    |   g:num

    |   \_

    |   \-
